#!/usr/bin/env ruby
class Instruction
  class A
    def initialize(value, symbol_table)
      @value, @symbol_table = value, symbol_table
    end

    attr_reader :value, :symbol_table

    def to_machine_code
      '0%015b' % address
    end

    private

    def address
      literal_address || symbol_table[value]
    end

    def literal_address
      Integer(value) rescue nil
    end
  end

  class C
    def initialize(dest, cmp, jmp)
      @dest, @cmp, @jmp = dest, cmp, jmp
    end

    attr_reader :dest, :cmp, :jmp

    CTABLE = {
      '0'   => '0101010',
      '1'   => '0111111',
      '-1'  => '0111010',
      'D'   => '0001100',
      'A'   => '0110000',
      '!D'  => '0001101',
      '!A'  => '0110001',
      '-D'  => '0001111',
      '-A'  => '0110011',
      'D+1' => '0011111',
      'A+1' => '0110111',
      'D-1' => '0001110',
      'A-1' => '0110010',
      'D+A' => '0000010',
      'D-A' => '0010011',
      'A-D' => '0000111',
      'D&A' => '0000000',
      'D|A' => '0010101',
      'M'   => '1110000',
      '!M'  => '1110001',
      '-M'  => '1110011',
      'M+1' => '1110111',
      'M-1' => '1110010',
      'D+M' => '1000010',
      'D-M' => '1010011',
      'M-D' => '1000111',
      'D&M' => '1000000',
      'D|M' => '1010101'
    }

    DTABLE = {
      nil   => '000',
      'M'   => '001',
      'D'   => '010',
      'MD'  => '011',
      'A'   => '100',
      'AM'  => '101',
      'AD'  => '110',
      'AMD' => '111'
    }

    JTABLE = {
      nil    => '000',
      'JGT'  => '001',
      'JEQ'  => '010',
      'JGE'  => '011',
      'JLT'  => '100',
      'JNE'  => '101',
      'JLE'  => '110',
      'JMP'  => '111'
    }

    def to_machine_code
      '111%{cmp}%{dest}%{jmp}' % {
        cmp: CTABLE.fetch(cmp),
        dest: DTABLE.fetch(dest),
        jmp: JTABLE.fetch(jmp)
      }
    end
  end
end

class Parser
  def initialize(program)
    @program = Array(program)
    @var_addr = 16
    @symbol_table = Hash.new { |hash, key| hash[key] = (self.var_addr += 1) }
  end

  def parse
    cleaned = clean(program)

    cleaned
      .reduce(cleaned) { |a, e| parse_label(e, a) }
      .map(&parse_instruction)
  end

  private

  attr_reader :program, :symbol_table
  attr_accessor :var_addr

  def parse_instruction
    -> (i) { parse_a(i) || parse_c(i) || fail(ArgumentError, i) }
  end

  def parse_a(i)
    match = i.match(/^@(.*)$/)
    return unless match

    Instruction::A.new(match[1], symbol_table)
  end

  def parse_c(i)
    match = i.match(/^(?:(\w+)=)?([10+\-!DAM&|]+)(?:;(\w{3}))?$/)
    return unless match

    Instruction::C.new(*match.captures)
  end

  def parse_label(i, program)
    match = i.match(/^\((.*)\)$/)
    return program unless match

    symbol = match[1]
    symbol_table[symbol] = program.index(i)

    program.reject { |e| e == i }
  end

  def clean(program)
    program
      .map(&strip_whitespace)
      .compact
      .reject(&:empty?)
  end

  def strip_whitespace
    -> (line) { line.gsub(%r{(//.*$|\s)}, '') }
  end
end

### Actual script
ARGV.each do |input_file|
  puts "Assembling #{input_file}..."
  output_file = input_file.gsub(/\.\w+$/, '.hack')

  program = File.read(input_file).split("\n")
  instructions = Parser.new(program).parse

  instructions
    .map(&:to_machine_code)
    .join("\n")
    .tap { |p| File.write(output_file, p + "\n") }

  puts 'Done!'
end
